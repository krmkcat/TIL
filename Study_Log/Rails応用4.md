# 2023.11.18
今日は「記事編集画面で更新・公開ボタンを押したときの挙動を実装」の続きから。

まずは全パターンを列挙。
- [x] 記事のステータスを「公開」または「公開待ち」、公開日時を「未来の日付」に設定して、「更新する」ボタンを押した場合  
--> 記事のステータスを「公開待ち」に変更して「更新しました」とフラッシュメッセージを表示

- [x] 記事のステータスを「公開」または「公開待ち」、公開日時を「過去の日付」に設定して、「更新する」ボタンを押した場合  
--> 記事のステータスを「公開」に変更して「更新しました」とフラッシュメッセージを表示

- [x] 記事のステータスを「下書き」に設定して、「更新する」ボタンを押した場合  
--> 記事のステータスを「下書き」に変更して「更新しました」とフラッシュメッセージを表示

- [x] 公開日時が「未来の日付」となっている記事に対して、「公開する」ボタンを押した場合  
--> 記事のステータスを「公開待ち」に変更して「公開待ちにしました」とフラッシュメッセージを表示

- [x] 公開日時が「過去の日付」となっている記事に対して、「公開する」ボタンを押した場合  
--> 記事のステータスを「公開」に変更して「公開しました」とフラッシュメッセージを表示


一番簡単そうな、「下書きにして更新」からいってみようかな。

更新ボタンを押したときの挙動は、「`admin_article_path`にデータが飛ぶ」だな。対応コントローラとアクションは`
admin/articles#update`.

…ん？これすでにできてるな。ブラウザでやっても普通に成功する。チェック入れて次行く。

ん〜、これどっちのボタンを押すかと更新後のステータスが何になるかで分けて考えたほうがいいのかな。書いてみるか。

- [x] 更新ボタン
  - [x] 公開待ちに変更
    - 公開or公開待ちを選択
    - 未来の日付
  - [x] 公開に変更
    - 公開or公開待ちを選択
    - 過去の日付
  - [x] 下書きに変更
    - 下書きを選択
- [x] 公開ボタン
  - [x] 公開待ちに変更
    - 未来の日付
  - [x] 公開に変更
    - 過去の日付

よし、これで整理された。今一度考えてみよう。
下書きor公開待ちに変更するには`admin/aritcles#update`で、公開にするには`admin/published#update`に飛ばす必要があるから、まずはそこで分岐が入るな。

いやでもそうするとフラッシュがコントローラ準拠で変わっちゃうな…。それはあくまで押したボタンによって変えたいんだけど。
ん〜〜まずは押したボタンごとでロジックくんでみるか。
（もしよそのコントローラのアクション呼び出したい場合は`render 'コントローラ名/アクション名'`でできる）

`admin/publishes#update`の内容をほぼそのままコピペしちゃった。これたぶん切り分けたほうがいいだろうけど、とりあえず動くか試してみよう。

注意：一つのアクション内で複数の`redirect_to`や`render`が存在する（分岐などで）場合、最後の物以外は`redirect_to ... and return`とする、もしくは単に`return`を後に付ける等してそこで処理が終了するようにすること。

更新ボタンを押した場合のロジックほぼできたけど、やっぱり下書き選択しても下書きにならないな。なんで？分岐で下書きの場合を最初に持ってきてみるか。

解決。`enum`の値をどう書くかの問題だったみたい。代入する場合は`:値`だけど、比較演算の場合は`'値'`じゃなきゃダメらしい。

…というわけでロジック自体はできた。けどどう考えてもリファクタリングしたほうがいいのでそれを考える。

ストロングパラメータの値は直接更新はできないんだな。ストロングパラメータの値を変更してからそのパラメータでデータを更新したい場合、一度パラメータを変数に代入してその変数で`update`すればOKみたい。
[参考リンク](https://fuyu.hatenablog.com/entry/2018/11/24/101720)

変更後のステータスが下書きor公開待ちになる場合のコードはだいぶスッキリした。問題は公開になる場合のコードだけど、途中で出てくるフラッシュメッセージだけ変えたい場合どうするのがいいんだろう。

いいや、先に公開ボタン押した場合の挙動を作ろう。

- 日付入力されてない
  - 公開処理
- 日付入力されてる
  - 過去
    - 公開処理
  - 未来
    - ステータスを公開待ちにして更新処理

ん〜〜これやっぱ`admin/publishes`コントローラにパラメータ飛んでないな、ただのリンクだし。てことはそこで飛ばし先を分岐させなきゃいけないのかな。
よし、見本サイトがどうなってるか見よう。

あそっか。公開ボタンはあくまで更新済みの`@article`の内容を反映したうえでステータスを切り替えてるだけだから、普通に`admin/publishes`コントローラで`@article.published_at`を参照して分岐すればいいのか。

あ〜というか更新ボタンの方、公開日時を空欄にして更新するとエラーになっちゃうな。これどうするべきなんだろ。

確認したら見本アプリでもエラー的なものが出るな。これはこのままでいいのか。

過去日付の記事で公開ボタンを押した場合のフラッシュ、「公開しました」にしろって書いてあるけど、これデフォルトの「記事を公開しました」とは別にメッセージだけを用意しなきゃいけないってこと？

確認したら見本だと「公開しました」で統一されとるやんけ…。とりあえず同じにしとこ。

比較演算式に`nil`が含まれてるとエラーになるんだな。どう対処しようか。
分岐を`@article.published_at`への代入の後にすればいいのか。
→無事解決。

ロジックは一通りできたかな。
一旦公開しないとステータス変えられないのは見本見る限り仕様っぽい。

あとはもう少しコードをすっきりさせたいけど、これはあれかな。モジュールに切り出すとかするといいのかな。
`concern`を使ってみるか。

モジュール作ってみた。レッツテスト。

うおおおできた！これで行こう。ネーミングはまあ後で考えてもいいや。

見本アプリでテストしてみてようやくわかった。これやっぱり「公開する」押すまでは反映されないんだ。ステータス「公開」で中身編集して更新しても、実際の公開ページは変わってない。
てことはモジュールとかいらないなたぶん…。

なんかおかしいと思ったら、ステータスが「下書き」のときは更新してもステータスのパラメータが飛ばないんだな。分岐の仕方変えなきゃ。

- 公開日時が空欄でもエラーが出ないのはステータスが「下書き」の場合のみ
- 逆に言うと下書き以外は公開日時が入力されてる前提でOK
- ステータスが現在「下書き」になっている記事は更新してもステータスのパラメータが送信されない

↑のことを念頭に置いて修正しよう。

よしできた。
一応ロボランテくんにリファクタリング頼んでみるか。

あーそうだった、`enum`の特定の値かどうかは自動生成されたメソッドで確認できるわ。
でもさすがに構成が複雑な上に情報が足りないせいでちょっと言ってることおかしいところがあるなロボらんてくん。
もう一個の方もお願いしてみよう。

よし、だいぶスッキリした。とりあえずこれでいいだろう。
もう次行っちゃう。


## タスクの自動化
いよいよ今回の山場だ。もう一回概要をチェックする。

- [ ] 記事のステータスが「公開待ち」で公開日時が過去になっているものがあれば、rakeタスクをライブラリ「whenever」により1時間ごとに走らせ、ステータスを「公開」に変更する
(※ 公開日時が過去で「公開待ち」となっているデータを画面上で更新しなくても、自動でステータスを公開に変更するようにしたい)
- [x] 現状、管理画面から1分単位で公開日時を指定できるようになっているが、1時間ごとに指定できるように変更する
(自動更新するcronの実行間隔が1時間毎なので、分単位で設定しても更新できないため)

まずは２つ目からやろうかな。フォームのコードを確認。

フォームオブジェクトの`as:`オプションはハッシュのキー名を指定してるんだな。

公開日時は`datetimepicker`っていう何かを使ってカレンダー選択式にしてるらしい。それの設定をいじれば1時間単位に変更できそう。

お、`assets/javascripts/admin.js`にそれっぽい箇所がある。

よしできた！
さあ今度こそ新要素バリバリの山場だ。やり方を調べよう。
…の前に一度コミットしとこうかな。メッセージは「記事ステータスに”公開待ち”を追加、記事更新・公開時の挙動を修正、公開日時の指定単位を1h事に変更」で。

コミットOK。
ロボらんてくんにざっくりと簡単にやり方をきいたところ次の回答。

>wheneverはRubyで書かれたスケジューリングツールで、定期的にRakeタスクやRubyスクリプトなどを実行するためのものだよ。>Railsプロジェクトでwheneverを使うには、まず以下の手順で設定するカナ。  
>1. Gemfileにwheneverを追加して、bundle installを実行してね。
>```rb
>gem 'whenever', require: false
>```
>2. インストールが完了したら、ターミナルでwheneverize .を実行して、プロジェクトディレクトリにconfig/schedule.rbファイルを生成するダ。  
>config/schedule.rbファイルを編集して、実行したいタスクとそのスケジュールを定義する。例えば、毎日午前2時にdb:backupというRakeタスクを実行するには、次のように書くカナ。  
> ```rb
>every 1.day, at: '2:00 am' do
>  rake 'db:backup'
>end
>```
>3. スケジュールを設定したら、crontabへの適用はwhenever --update-crontabを実行することで行える。これでシステムのcronにタスクが登録されるダ。  
>もしスケジュールを確認したいなら、wheneverコマンドを実行すると、現在のschedule.rbの内容がcron形式で出力されるからチェックしてみて。  
>  
>これで基本的なwheneverの設定は完了だよ。細かいスケジュールの設定やオプションについては、wheneverのドキュメントを参照してみてね。

わかりやすい。rakeタスクの作成方法についても訊いてみた。回答は以下。

>Rakeタスクを作成するには、Railsアプリのlib/tasksディレクトリに.rakeという拡張子を持つファイルを作成するんだ。以下はその手順だよ。
>
>lib/tasksディレクトリに新しいファイルを作成する。ファイル名はタスクに関連した名前でいいよ。例えばbackup.rakeとしよう。
>
>作成したファイルにRakeタスクを定義する。以下はdb:backupという名前のタスクを定義する例だね。
>```rb
>namespace :db do
>  desc "Back up the database"
>  task backup: :environment do
>    puts "Database backup started..."
>    # データベースバックアップのスクリプトをここに書く
>    puts "Database backup completed."
>  end
>end
>```
>タスクを実行してみたい場合は、ターミナルで以下のコマンドを使うよ。
>```shell
>rake db:backup
>```
>これでRakeタスクが作成できたし、実行もできるようになったはずだ。自分でタスクの中身を書く時には、実行したいスクリプトやRailsのモデルを使った処理を記述してみてね。

よし、概ねわかったので今度は記事を参照して合ってるか・抜けがないか確かめよう。
- [whenever参考リンク](https://qiita.com/mmaumtjgj/items/19e866f31541abb6c614)
- [whenever公式ドキュメント](https://github.com/javan/whenever)
- [rakeタスク参考リンク](https://qiita.com/mmaumtjgj/items/8384b6a26c97965bf047)

まずrakeタスクを作成してみる。コンテナ内で`rails g task タスク名`だな。タスク名は"publish_articles"にしよう。

合ってるかはわからないけどいちおうできた。
今日はここまで。明日は`find_each`のまとめとか`where`のおさらいとかをTILに書くところから始めよう。