# 2023.11.30
ブランチ切った！課題の概要を確認する。

なるほど把握。  
まずは今回のポイントになっているPunditなるものが何なのか確認。それから権限の記述箇所を探す。わざわざやらせるってことは当然これまでとは違うやり方してるってことだな。

Punditについて。予想通りGem。認可の仕組みを簡単に使えるようにしたものらしい。`app/policies/`下のファイルに設定が書いてあるっぽいかな？
[こちらの記事](https://qiita.com/yutaro50/items/52484b7ae4ca87aa99a2)参照。

なんとなくはわかったので、さっそく実際のファイルを見てみよう。

あった。タグ・著者・カテゴリーは全部`TaxonomyPoicy`を継承してるから、ここに書けば一度に反映させられるな。

よし、権限の設定はたぶんできた。あとは403エラーページだけど…これは何をお手本にしたらいいんだ？サンプルアプリはadminユーザー以外の情報ないよね？どういうページが表示されればいいのかわからん…。  
まあまずはどうやって任意のエラーを出すかを調べるか。

なるほど。Punditを使った認可が拒否された場合は全部`Pundit::NotAuthorizedError`が出ることを利用して、`rescue`を使えばいいんだな。  
まずはとりあえず[参考にした記事](https://qiita.com/mmaumtjgj/items/c7fc40619a15cce5ccfc)に載ってたコードをコピペしてエラーページを作ろう。

できた。次に`rescue`で`Pundit::NotAuthorizedError`を捕捉して`403.html`をレンダリングする。

いちおうできたのでブラウザからテストする。開発環境だと表示されない云々はやってみてダメだったら設定いじる。

あ、サンプルアプリは見れないようになってるけど、自分のにはちゃんとエディターユーザーもライターユーザーも用意されてた。作らなきゃと思ったけど必要なかったな。早速ログインし直して試してみよう。

…というかたぶんサンプルアプリも「writer」「password」でいけそうな気がしてきた。試してみよう。

できたー。共通レイアウトも無視して全画面表示、かつシンプルに「権限がありません」の文のみでいいんだな。  
というかやっぱりさっきの記事RUNTEQ生が書いたやつだな…こういうのはネタバレとは言わないんだろうか。まあいいや、`403.html`はさっきのコードコピペに戻そう。

さて、ここからやることとしては雑に言うと、
1. `Pundit::NotAuthorizedError`を`rescue`で403エラーにするように設定する
2. そのままだと本番環境でしか`public/403.html`が表示されないので、開発環境でも表示されるように一時的に設定を変更する（確認し終わったら戻す）

の2点かな。
正直2.のほうは記事読んでもイマイチ意味がわからない（ひょっとすると説明が正確ではない？）けど、とりあえずやってみる。

`config/application.rb`に以下を追記する。
```rb
config.action_dispatch.rescue_responses["Pundit::NotAuthorizedError"] = :forbidden
```

次に、`config/environments/development.rb`の記述を以下のように変更する。
```rb
config.consider_all_requests_local = false
# 初期値は"true"
```

よし！両方できたので、サーバー再起動して早速ブラウザでテスト。

良さげ。見本のspecファイルでテストしてみよう。

OK!設定戻して、自分でテスト書こう。

## RSpec
さて、まずはそれぞれのroleのユーザーを作れるよう、userのFactoryに`trait`を設定しよう。
…と思ったらすでにあった。さっそくテスト書いていこう。

あ、ちがう！しまった。一つ前のspecに戻すの忘れてた。

よし、specを一つ前の課題の状態に戻した。

ある程度のところまで書いたので一旦走らせてみよう。

あ、やっぱり設定戻しちゃダメなんだ。テスト時も`config.consider_all_requests_local = false`にしないといけないね。というか今度は`config/environments/test.rb`の方をいじらないとダメかも。やってみよう。

ん〜〜`test.rb`と`development.rb`両方いじってみたけどダメだ。むしろ`"Pundit::NotAuthorizedError"`が出るかどうかをテストしたほうがいいのか？

あ〜やっぱそうっぽい。別の課題でも見た[元RUNTEQ生のネタバレ記事](https://sakitadaiki.hatenablog.com/entry/2021/02/08/132250)が引っかかってきた。見ちゃったものはしょうがないからこのまま書いてあるとおりにやってみよう。

ん〜〜テスト自体はできるようになったけど、なぜかステータスコード302が返ってきてるみたい。なんで？？
しかもアクセス先を記事一覧ページにしても同じ結果。こっちはこっちで200にならないとおかしいんだけど…。ひょっとしてログインマクロが使えてない？

検証の結果、たぶんログインはできてる。なのになぜかどこにアクセスしても302になる…なんでよ？？

全然わからん…本日はここまで。明日も一応少し考えるけど、30mやってだめだったらもう諦めてプルリクしよう。

# 2023.12.1
引き続きテストがうまく以下ない原因を探る。  
ロボらんてくんに助言を求めたところ、やっぱりログインがうまくいっていないのではという疑惑が。再度マクロを使わず直書きして、そのあとにテスト内容を続けて書いてみよう。

結局ダメでいろいろ試したんだけど、どうもログインには成功してて、成功したときのレスポンスをそのまま拾っちゃってるっぽい気がする。`get admin_categories_path`ができてない？これ`visit`にしてみたらどうなるかな。

だめだ〜。302が空欄に変わっただけ。これはどういうことなのレスポンスがないってことなの？

禁じ手って感じだけど、例の記事のコード丸ごとコピペしてみるか。どうなるだろう。

えっなんで？なんか実行されるテストが1つだけになっちゃったんだけど…。

どうやら`it`じゃなく`fit`になってたからっぽい。そしてそれ直したら通った…。あれか？`expect(response)`じゃなくて`expect(page.status_code)`にしたからなのか？2つの違いをロボらんてくんに聞いてみる。

う〜ん結局なんで`expect(response)`じゃだめなのかはっきりとはわからなかった。本番環境とテスト環境の違いとかそういうのも関わってきちゃうかもらしい。  
正直全然スッキリしないけど、ここで時間食ってても仕方がないから少しだけかきなおしてもうプルリクすることにする。

よし、とりあえずLGTM。今日はここまでにしよう。

# 2023.12.2
復習開始。今回はたぶんRSpecのほうがメインだろうな。まずは復習ポイントをチェック。

うん、思った通り復習ポイントには特に新しい情報はないな。  
開発環境でのエラーページ表示については解説みてもいまいち理解できない。ロボらんてくんに解説お願いしようかな。

続いてコードの見比べ。たぶんアプリの方は全く同じになってるだろうな。RSpecがどうなってるかはちゃんと確認しよう。（まあこれもネタバレ記事見てやったからほぼ同じだろうけど…）

あ〜リンクの表示がされてるかどうかのテストは忘れてたな完全に。確かに必要だ。これは追記しなきゃだ。

全体的に前回とは打って変わって丁寧に全部のパターンテストしてるな。あと`expect(page.status_code)`じゃなくて`expect(page)`になってるけどこれはOKなのか？これでいいならそもそも`driven_by(:rack_test)`にする必要ないのでは？？修正ついでに試してみるか。

コード少し書き換えてテスト走らせたらなんか変なエラーでた〜。
```
Failure/Error: ActiveRecord::Migration.maintain_test_schema!

ActiveRecord::ConnectionNotEstablished:
  Can't connect to server on 'db' (115)
```
DBサーバーに接続できないとか言われてる。エラー名で調べたけど難しくてよくわからん…。とりあえずコンテナ再起動してみるか。

普通にいけた。やはり再起動はすべてを解決する…！  
引き続き修正していく。

ライターの権限テスト書き終えたから走らせてみたらいけた。えっ、`expect(page).to have_http_status(403)`でいいんじゃん。`status_code`メソッドだけじゃなくて`have_http_status`っていうマッチャーもCapybaraだと使えないってことか？試してみよ。

そうらしい。
```
Capybara::NotSupportedByDriverError:
  Capybara::Driver::Base#status_code
```
というエラーが出てる。いちおうロボらんてくんにも確認してみるか。

ロボらんてくんによると、`have_http_status`はCapybaraでは使えないけど、`page.status_code`はCapybaraでも使えるらしい。マジ？やってみよ。

だめじゃん…。なんでダメなのかロボらんてくんに訊いてみたけど、やっぱりなんかよくわからん。CapybaraのRackTestでは`status_code`は使えないって言ってるけど`driven_by(:rack_test)`にすると使えるし…。どういうことなの。

問いただしてみたら、「ごめんさっきのは間違い。RackTestは`status_code`メソッドをサポートしてるよ」とのこと。言ってること真逆やんけ〜！ほんと意外と間違ったこと言うよなあ。まあ素のGPTと違ってロボらんてくんは可愛いから許せるけど。

結局まとめると、ステータスコードを検証できるようなメソッドやマッチャーはRackTest（というドライバー）じゃないと使えない。だから今回のテストでは`driven_by(:rack_test)`を書く必要がある。（デフォルトでは別のドライバーを使う設定になってる）  
…ってことか。

そもそもRSpecにおけるドライバーとはなにか？とかCapybaraとはなにか？みたいな疑問もあるけど、そこは一旦スルーしとこう…きりがない。

テストコードの修正に戻る。

よしできた！  
修正が終わったので新要素のまとめに入る。

- [x] Pundit
- [x] 開発環境におけるエラー画面の表示について
- [x] ステータスコードのテストについて

Punditのまとめ、だいたいOKだけどconfigに記述したコードの意味をきちんとは把握できてないのでロボらんてくんに解説お願いしてみる。

な〜るほど〜〜！さすがロボらんてくん。今回出てきたconfig周りの記述についてめちゃくちゃわかりやすい説明をしてくれた。

よし、あとはRSpecでのステータスコードを使ったテストについてまとめておしまいだ。

できた〜。これにて復習完了。