# 2023.11.24
ようやく前回の課題に関するまとめが終わったので次の課題に移る。  
まずはブランチを切って課題の概要を把握。

把握。要件そのものはシンプルで、以下の要素による検索機能（下書き記事含む）を追加せよとのこと。
- 著者（セレクトボックス）
- タグ（セレクトボックス）
- 記事内容（フリーワード）

とりあえずすでに実装済みの検索機能を確認する。
位置としては`admin/articles/index.html.slim`の12行目からだな。
中身を読む。

ransackは使ってないっぽいな。`SearchArticlesForm`っていうクラスを用意して、そこにフォームデータを送信してる。
`SearchArticlesForm`は`app/forms`ディレクトリの中。
`ActiveModel::Model`と`ActiveModel::Attributes`を`include`してる。疑似モデルってとこかな？

一旦コードの意味をロボらんてくんに解説してもらおう。
その前にバージョンメモ。
- Railsのバージョン：7.0.4
- Rubyのバージョン：3.1.4

以下回答。
>このコードは、記事を検索するためのフォームオブジェクトを定義しているよ。1行ずつ解説するね。
>
>```rb
>class SearchArticlesForm
>```
>SearchArticlesFormという名前のクラスを定義している。クラス名からこのクラスが記事を検索するフォームの機能を持つことが予想される。
>```rb
>  include ActiveModel::Model
>```
>Active Modelのモジュールをインクルードしていて、これによってRailsのモデルと似たような機能（バリデーションなど）をこのクラスに追加している。
>```rb
>  include ActiveModel::Attributes
>```
>Active ModelのAttributesモジュールをインクルードしており、属性の型を定義できるようになっている。
>```rb
>  attribute :category_id, :integer
>```
>category_idという整数型の属性を定義している。これは記事のカテゴリーを指定するために使われる。
>```rb
>  attribute :title, :string
>```
>titleという文字列型の属性を定義していて、これは検索する記事のタイトルを指定するために使われる。
>```rb
>  def search
>```
>searchというインスタンスメソッドを定義している。このメソッドは検索処理を実行する。
>```rb
>    relation = Article.distinct
>```
>Articleモデルの全てのレコードを取得し、重複を排除した状態のクエリオブジェクトを変数relationに代入している。
>```rb
>    relation = relation.by_category(category_id) if category_id.present?
>```
>category_idが存在する場合（nilや空でない場合）、by_categoryスコープを使って、そのカテゴリーIDに基づく記事を絞り込んでいる。
>```rb
>    title_words.each do |word|
>```
>title_wordsメソッドで得られたタイトルの各単語に対してループ処理を開始している。
>```rb
>      relation = relation.title_contain(word)
>```
>title_containスコープを使って、各単語が含まれる記事で絞り込みを行っている。ここでrelationはさらに絞り込まれていく。
>```rb
>    end
>```
>各単語に対するループ処理が終了する。
>```rb
>    relation
>```
>最終的に絞り込まれた記事のクエリオブジェクトをメソッドの戻り値として返している。
>```rb
>  end
>```
>searchメソッドの定義が終わっている。
>```rb
>  private
>```
>以下のメソッドはこのクラスの外部からは呼び出せないプライベートメソッドであることを示している。
>```rb
>  def title_words
>```
>title_wordsというプライベートメソッドを定義している。これはタイトルを単語に分割するためのメソッドだ。
>```rb
>    title.present? ? title.split(nil) : []
>```
>タイトル(title)が存在する場合はそのタイトルを空白文字で分割して単語の配列にし、存在しない場合は空の配列を返している。
>```rb
> end
>```
>title_wordsメソッドの定義が終わっている。
>```rb
>end
>```
>SearchArticlesFormクラスの定義が終わっている。
>このクラスは、指定されたカテゴリーとタイトルの単語を含む記事を検索するために使われるんだ。

ちなみに`distinct`メソッドはレコードの重複を除くというもの。なぜこの場合に必要なのかは今のところわからず。  
あと`by_category`とか`title_contain`は何者？と思ってたけどscopeだということが判明。たしかにメソッド以外にそういう可能性もあったな。覚えておこう。

大まかな実装方針としては
- `attribute`を追加
- scopeを追加
- 絞り込みロジックを`search`アクションに追加
- ビューにフォームを追加

って感じかな。
まず`attribute`の追加から着手するか。

必要な`attribute`は
- author_id(integer)
- tag_id(integer)
- body(string)

かな…？記事内容がちょっと自信ないというかまだよくわかってない。あくまで文章ブロックのみ対象でいいのか？  
一旦そこは保留にして追加する。

OK。次にscopeの追加。

OK。次は絞り込みロジックの追加。既存のを参考にやってみよう。

よし。ここまではOK。次にフォームの追加。

セレクトボックスの作り方。[参考記事](https://310nae.com/rails-selectbox/)
```erb
<%= f.select( プロパティ名, 選択肢, {オプション}, {HTMLオプション} ) %>
```
プロパティ名は送信する際のパラメータ名。通常はカラム（属性）名にすることが多い。なおHTMLオプションを使う場合は、無印オプションを省略できない。かならず空の大かっこを入れること。

`index.rb`見てて思ったんだけど、`=>`って何？どういう書き方？Slimの記法調べても出てこないんだけど…。ロボらんてくんに訊いてみるか。

ロボらんてくんにもしらんて言われた…。正確には「タイプミスじゃないかな」だけど。いいや一旦ほっとこう。

`pluck`について調べてたら`distinct`が必要な理由がわかった。これは`distinct`を呼び出した時点で重複を取り除くんじゃなくて、発行されるSQL文が`SELECT DISTINCT ...`になるっていう意味なんだたぶん。だから`モデル.distinct`としておいて、その後にどんなクエリが来てもレコードが重複しないようにしてるんだ。それこそ`pluck`は返り値が配列になるからメソッドチェーンの最後に持ってこなきゃいけないし。なるほどなあ。

よし、著者とタグのセレクトボックスはできた。次は記事内容のフォームだな。作るだけ作って、それから”記事内容”が実際には何を指すのか確かめよう。
今日はここまで。

# 2023.11.25
続きをやる。今日は著者での検索機能完成を目標にしたので、予定を変更して、先に著者検索だけでブラウザテストしてみる。

あれ、できない。昨日やったことだけでもうほぼ完成なんじゃと思ってたけどやっぱり違ったか…。最初からあるカテゴリーとタイトル検索はどうなってるんだろう？

こっちは普通にできる…。ええ〜なんで？

ストロングパラメータの設定を修正してなかった。直したらできた！とりあえず今日の目標は達成だ。  
あとついでに公開日の表示に余計なものが入ってるのに気づいたのでこれを消す。

う〜ん思ったより時間かかりそうなのでやっぱり後回しにする。

タグの検索機能行こう。タグは複数設定OKなところが他と違うからそこを考慮しないと。昨日書いた絞り込みロジックを修正する必要があるかも。

…の前に、このフォームの仕組みをざっくりと把握しておこう。

### 検索フォーム周りのざっくりとした仕組み
- `SearchArticlesForm`クラス
  - 疑似モデルクラス。これにより検索条件を1つのモデルインスタンス（のようなもの）として扱える
  - `search`メソッド：`SearchArticlesForm`クラスのインスタンスメソッド。`SearchArticlesForm`インスタンスを検索条件として、実際にデータの絞り込みを行う
- 検索フォーム
  - `admin/articles/index.html.slim`内にある`@search_articles_form`と紐づいた検索フォーム
  - 送信先は`admin_articles_path`（つまり`Admin::Articles#index`）
  - データベースの書き換えはしない（パラメータ飛ばすだけ）ので、**HTTPメソッドはGET**
- `Admin::Articles`コントローラ
  ```rb
    def index
      authorize(Article)

      @search_articles_form = SearchArticlesForm.new(search_params)
      # 検索フォームから送られてきたパラメータを元にSAFインスタンスを生成しインスタンス変数に代入

      @articles = @search_articles_form.search.order(id: :desc).page(params[:page]).per(25)
      # SAFインスタンスを基にデータの絞り込みを行い、並べ替えとページネーションの設定をし、その結果をインスタンス変数に代入
    end
  ```

よし、だいたい把握できた！  
改めてタグ検索の実装に取り掛かろう。

TagとArticleは多対多の関係なんだよな。これをうまくscopeに落とし込む方法を考えないと。  
アソシエーション使った書き方ってこの場合使えるのかな。使えるならそれが一番簡単そうだけど。  
いやだめか。単体のレコードに対してじゃないと使えないな多分。`where`とか`join`使って書くしか無いか。

ん〜〜、やりたいこととしては「idが`tag_id`であるタグが付いているArticleをすべて取得」なんだよな。`Tags.find(tag_id).articles`って感じ。ただあくまでレシーバーはArticlesにしたいんだよなあ。

とりあえず書いたので試してみる。

`TypeError:no implicit conversion of Symbol into String`がでた。シンボルじゃなくて文字列で書かないといけない部分があったらしい。  
あ、じゃなくてたぶん`joins`が`join`になってるせいかも。直してみる。

今度は`ActiveRecord::StatementInvalid at /admin/articles
Mysql2::Error: Unknown column 'articles.tag_id' in 'where clause'`。

解決＆実装成功！`where`をシンボル使って書く場合は、あくまで大元の（この場合`Articles`の）カラムしか条件に使えないんだ。結合した`article_tags`のほうのカラムを条件にしたい場合はプレースホルダー使って文字列でSQL書くしかないらしい（`article_tags.tag_id`みたいに）。

よーしこれで著者とタグはOK。残るは記事内容か。これが具体的に何を示してるのかまず確かめなきゃ。  
コンソール使って直接`body`になにか入れてみるか。

実験の結果、どうやら文章ブロックの内容のことらしい。article_blockは未だにどういう仕組かよくわかってないんだよなあ…。まずそこを解き明かすところからか〜。頑張る。

その前に、ずっと気になってたuuidについて調べた。Universally Unique IDentifier の略だそうだ。
通常のidだと単純すぎて色々推測できてしまうことがあるので、それを防ぐために規則性のないランダムなidを別に割り振り、それをパラメータ等に使っているということらしい。
[参考リンク](https://zenn.dev/yusuke_docha/articles/1b162804f7ea12)

話を戻してブロックの仕組みを調べる。  
とりあえず`ArticleBlock`クラスのコードを見た。`blockable`っていうのは`Sentence`、`Medium`、`Embed`の総称っぽいな。ようするに個々のブロックのこと。  
で、ここを勘違いしてたけど`ArticleBlock`は中間テーブルだ。`Article`と個々のブロックを繋いでる。  
ただし個々のブロックは3種類あってそれぞれ別のモデルだから、`blockable`っていう名称（関連名）をつけることで扱いやすくしてる。  
`Article`モデルの関連付けで`source: :blockable, source_type: 'Sentence'`って書いてるけどそんなことできるのか。sourceは必ずしも実在のモデルである必要はないってこと？ちょっと調べてみよう。

どうやらポリモーフィック関連付けというやつが関連している？

ビンゴ。  
ポリモーフィック関連付けとはなにか、ざっくりいうと「
異なるモデルを一つのグループとして扱えるようにする機能」。今回でいうと、`Sentence`、`Medium`、`Embed`という3つのモデルを`blockable`というグループにまとめている。グループ化する際の名称はどうやら`〇〇able`にするのが通例っぽい。  
詳細は[公式ドキュメント](https://railsguides.jp/v7.1/association_basics.html#%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)参照。あとでまとめよう。

さてと、じゃあまず`Sentence`タイプの`blockable`をもつ`Article`を取得する方法を考えるか。そこからさらに`Sentence`の`body`の内容で絞り込みをかける方法を考える。

書いてみたので試してみる。

できてなかった。検索フォーム追加するの忘れてた。
フォーム追加したんだけど、`=>`の`>`はスペース空けるのに使ってる？`=`だと見本通りにフィールドの横に空白ができないな〜と思って、試しに`=>`にしたら見本通りになった。う〜ん謎。

お、検索機能自体はできたっぽい。ということは要件はもう満たせたのか？テストダウンロードしてやってみるか。

お、ほぼいい感じ。ただやっぱり記事内容は`body`っていう名前にしてるっぽいな。こっちに統一しよう。あとプレースホルダー忘れてたからそれも追加。

プレースホルダーについて。フィールドはOKだけど、セレクトボックスは意外と面倒そうなので一旦パス。あとでもう一回確認する。

OK！機能自体は完成。ここで一旦コミットしとこう。

さて、じゃあセレクトボックスのプレースホルダーを設定するか。見本に合わせて、プレースホルダーも選択可能だけどその場合値が`nil`になる、っていう挙動にしよう。

OK！そうしたら後はリファクタリングかな。  
できるとしたら`SearchArticleForm`だな。`relation`が大量に並んでる部分。うまくまとめられるかなあ。

う〜ん思いつかない。ロボらんてくんに頼んでみよ。

Articleモデルに提議したscopeを踏まえると、基本OKだけど、ワード検索は`inject`メソッド使ってもう少しスッキリさせられるよ、とのこと。
`inject`については[Rubyリファレンスマニュアル](https://docs.ruby-lang.org/ja/latest/method/Enumerable/i/inject.html)参照。こんな便利なメソッドあったんか…。

一応書けた。今日はここまで。明日はリファクタリングしたところが本当にこれでいいか再度確認して、それからRSpecの作成に入る。

# 2023.11.26
今日はリファクタリングした箇所がこれでいいか再度確認して、その後RSpecのテスト作成に入る。目標は著者での検索機能のテストを完成させること。

よし、アプリのコードはこれで完成。次はRSpecのテストを作成する。今のspecを消して、一つ前の課題のお手本specをもう一度入れる。

入った。まずはFactoryBotからいこう。User、Article、Category、Tagはすでにあるので一旦よし。新たにAuthor、Sentenceを追加する。

今気づいたけど、Author、Category、Tagモデルは全部taxonomiesテーブルに属してるのか。一つのテーブルに複数のモデルが属することがあるんだな。これも`type`でどのモデルか見分けてるんだな。ポリモーフィック関連付けに似てるけど、関連付けを見るとそうではないみたい。あと3つのモデルがそれぞれTaxonomyモデルを継承してる。  
気になるので調べてみる。

単一テーブル継承（Single Table Inheritance）というらしい。全く同じカラム構成のテーブルを複数作る代わりに、親となる汎用テーブルを一つ作って、それを継承した疑似テーブル（モデル）を複数作るというやり方。疑似テーブルはあくまで擬似であって、モデルとしては存在するがDB上のテーブルとしては存在しない。今回で言うAuthor、Category、Tagがそう。親がtaxonomiesテーブル。  
疑似テーブルのデータはすべてtaxonomiesに格納されるが、`type`の値によってどの疑似テーブルのデータか見分けがつくようになっている。  
[こちらの公式ドキュメント](https://railsguides.jp/association_basics.html#%E5%8D%98%E4%B8%80%E3%83%86%E3%83%BC%E3%83%96%E3%83%AB%E7%B6%99%E6%89%BF-%EF%BC%88sti%EF%BC%89)や、[こちらの記事](https://qiita.com/niwa1903/items/218713c076fb0075712f)参照。

なるほど〜〜。前回課題のテストで「Categoryの`type`ってなんで必要なの？」「`type`ってなにを表してるの？」って思ってたけど、そういうことだったのか。
ポリモーフィック関連付けとSTIは重要そうなので後でまとめよう。

話を戻してFactoryBot。Categoryを単独のデータ種別として扱っているということはモデルベースで作っていいってことだな。AuthorのFactoryBotを作ってみよう。

よし、次はSentenceを作る。

OK。テストコード書く。

書けた。とりあえず走らせてみよう。

`let`は`describe`か`context`の中に書かなきゃダメよって怒られちゃった。`it`の中はダメなんだそうだ。

う〜〜んうまくいかない。なぜか検索結果が0になっちゃう。なにがまずいんだろ？

~~あと、この後のテストのこと考えると`<tr>`タグに各記事のid振っといたほうがいいかも。~~  
→いらないかも。一旦消して、後でまた必要になったら戻す。

記事にカテゴリーを設定するんじゃなくてカテゴリーに記事を追加したら何故かうまくいった。なぜ？？？

とりあえずカテゴリー検索のテストはできた。idは結局テーブルそのものに振った。

よし、次に今日の目標・著者での検索機能のテスト作成だ。これはほぼカテゴリーのコピペでいけるだろう。

よし、著者検索もOK！次、タグ検索。

OK。次、記事内容。

OK。ラスト、タイトル検索。記事内容検索とほぼ同じかな。

ん〜なぜかうまくいかない。さっきと同じで記事タイトルの代入がうまくできてない？？

あ、わかったかも。`create`ですでにDBに保存されてるものに対して属性を上書き代入しても、`save`しなきゃ反映されないってことでは。インスタンス変数じゃないから。

当たり。どうしてもインスタンス変数の感覚でやっちゃうな。気をつけよう。

さて、やっぱり各記事の`<tr>`要素にidがないとやりづらい気がするので割り当てることにする。今のままだとタイトル検索がちゃんとできてるかの検証ができない。

`have_selector`を使って指定したidの記事のがページ内に存在するか確認する方式にしたらいけた！残りのテストも全部これに書き換えよう。

よーし！テスト全部かけたし通った！コミットプッシュプルリクする！

案の定Lintチェックでいくつか引っかかったわけだけど、インデントはスペース2つで！ってやつ、どうしろと？可読性の都合なんだけどなあ。
まあいいや直せるやつから先にやっていこう。

`joins`で結合したテーブルのデータを`where`で条件として使う場合、`where(結合したテーブル名: {結合したテーブルのカラム名: 値})`という書き方ができる。原則としてSQL文を文字列として書くやり方は、そうじゃないと実現できない場合（比較を含むなど）のみにすること。

「RedundantInterpolation: Prefer `to_s` over string interpolation.」は変数展開するより`to_s`使ってね、ということらしい。`"#{tag_id}"`よりも`tag_id.to_s`にしろってことね。文字列と組み合わせずに、変数単体で文字列扱いしたいならそっち推奨ってことね。

スペースどうこうのやつはもう`=`で改行しちゃおう。

`search`メソッドは、最後の行は`relation = search_with_title(relation)`じゃなくて`search_with_title(relation)`でOK。というかそうしないとLintチェックに引っかかる。メソッドの中で何度も`relation`に再代入してるのは結果を次の処理に渡すためだから、最後の処理には必要ない。

**LGTM出た〜！**  
思ったより全然スムーズにできたなあ。目安24hっていうからどんだけ沼かと思ったら。  
とりあえず復習ポイントさらっと流し見して、一旦休憩しよう。

セレクトボックスへのプレースホルダーの設定の仕方とRSpecの書き方くらいかな、ちゃんと確認が必要なのは。あとは概ね良さそう。
では休憩。

休憩終わり、復習開始。  
まずはセレクトボックスの修正。あの形式のプレースホルダーは`{ include_blank: 'プレースホルダー' }`で実装できると。

修正OK。次はRSpecか。なんか知らない要素登場してたな確か。
`after_build`と`transient`だ。まずこいつらについて調べる。

- `transient`
  - FactoryBotのメソッド
  - モデルとは直接関係ない属性を新たに付与できる
- `after(:buildや:create) { ブロック }`
  - FactoryBotのコールバックメソッド
  - 指定したメソッドの直後にブロック内の処理を実行する

[参考リンク](https://qiita.com/piggydev/items/32717b6c382272e2134e)

ん〜〜、なんとなく把握はできたんだけど言葉で表すのが難しいな…。

というわけでロボらんてくんに解説をお願いした。以下回答。

>1. transient: transientはFactoryBotで使われるブロックの一種で、ここに書かれた属性はデータベースに保存されるオブジェクトの属性としては使用されないよ。一時的な属性やテスト実行中にだけ必要な計算用の値を設定するのに使われるんだ。
>
>1. evaluator: evaluatorはFactoryBotのtransientブロック内で定義された属性にアクセスするために使われるオブジェクトだよ。これを使って、transientで定義された属性の値に基づいて、オブジェクトの生成時に特定のロジックを実行できるんだ。
>
>1. after: afterはFactoryBotでオブジェクトが生成された後に特定のアクションを実行するためのコールバックだよ。例えば、オブジェクトがデータベースに保存された後に関連するオブジェクトを作成したり、何かの属性を変更したりするのに使われるね。

さすが。わかりやすい。  
これを踏まえて復習ポイントのコードを改めて見てみよう。

だいたい把握できた。自分のコードを書き直そう。

今日はここまで。明日はテストコード修正の続きから。

# 2023.11.27

テストコード修正の続き。  
見本のやり方だとidは要らないな。複数ワードでの検索に対応してないからか。でもこれは合ったほうがいいと思うのでこのままにしておこう。

ええ〜？`article_with_tag.tag_name`ができないのなんで？`tag_name`なんてメソッドは無いって言われる…。`article_with_author.author_name`は普通にできてるのに。
あとタグ自体はちゃんと出来てるしアソシエーションもできてる。なんで？？？

見本に倣って著者名もタグ名も普通に文字列で指定することにした。よく考えたら`tag_name`はあくまで疑似カラムで実際のDBやモデル上にはないから、メソッドがないって言われるのはわかる。でもだとすると逆になんで`author_name`はOKだったのかわからない。もうこれはちょっとよくわからないのでスルーすることにする。

さて、テストコードの修正は終わった。一応アプリのコードの方も見比べておこう。

うん、特に直さなきゃいけないところはないな。

よし、それじゃあ新しく出てきた要素についてまとめていくか。

- [x] `distinct`
- [ ] Slimの`=>`
- [x] Slimで`id`や`class`を動的に生成する方法
- [x] uuid
- [x] ポリモーフィック関連付け
- [x] `inject`
- [ ] 単一テーブル継承
- [x] `joins().where()`の書き方
- [ ] `transient`と`after`

こんなもんかな。特に重要なのはポリモーフィック関連付け、単一テーブル継承、`transient`と`after`かな。あと唯一未だにさっぱりわかってないのが`=>`。

まず比較的シンプルなやつからいくか。

シンプルなやつ終わり。次はポリモーフィック関連付け行こうかな。

OK。きょうはここまで。明日は単一テーブル継承やろうかな。