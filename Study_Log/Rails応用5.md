# 2023.11.24
ようやく前回の課題に関するまとめが終わったので次の課題に移る。  
まずはブランチを切って課題の概要を把握。

把握。要件そのものはシンプルで、以下の要素による検索機能（下書き記事含む）を追加せよとのこと。
- 著者（セレクトボックス）
- タグ（セレクトボックス）
- 記事内容（フリーワード）

とりあえずすでに実装済みの検索機能を確認する。
位置としては`admin/articles/index.html.slim`の12行目からだな。
中身を読む。

ransackは使ってないっぽいな。`SearchArticlesForm`っていうクラスを用意して、そこにフォームデータを送信してる。
`SearchArticlesForm`は`app/forms`ディレクトリの中。
`ActiveModel::Model`と`ActiveModel::Attributes`を`include`してる。疑似モデルってとこかな？

一旦コードの意味をロボらんてくんに解説してもらおう。
その前にバージョンメモ。
- Railsのバージョン：7.0.4
- Rubyのバージョン：3.1.4

以下回答。
>このコードは、記事を検索するためのフォームオブジェクトを定義しているよ。1行ずつ解説するね。
>
>```rb
>class SearchArticlesForm
>```
>SearchArticlesFormという名前のクラスを定義している。クラス名からこのクラスが記事を検索するフォームの機能を持つことが予想される。
>```rb
>  include ActiveModel::Model
>```
>Active Modelのモジュールをインクルードしていて、これによってRailsのモデルと似たような機能（バリデーションなど）をこのクラスに追加している。
>```rb
>  include ActiveModel::Attributes
>```
>Active ModelのAttributesモジュールをインクルードしており、属性の型を定義できるようになっている。
>```rb
>  attribute :category_id, :integer
>```
>category_idという整数型の属性を定義している。これは記事のカテゴリーを指定するために使われる。
>```rb
>  attribute :title, :string
>```
>titleという文字列型の属性を定義していて、これは検索する記事のタイトルを指定するために使われる。
>```rb
>  def search
>```
>searchというインスタンスメソッドを定義している。このメソッドは検索処理を実行する。
>```rb
>    relation = Article.distinct
>```
>Articleモデルの全てのレコードを取得し、重複を排除した状態のクエリオブジェクトを変数relationに代入している。
>```rb
>    relation = relation.by_category(category_id) if category_id.present?
>```
>category_idが存在する場合（nilや空でない場合）、by_categoryスコープを使って、そのカテゴリーIDに基づく記事を絞り込んでいる。
>```rb
>    title_words.each do |word|
>```
>title_wordsメソッドで得られたタイトルの各単語に対してループ処理を開始している。
>```rb
>      relation = relation.title_contain(word)
>```
>title_containスコープを使って、各単語が含まれる記事で絞り込みを行っている。ここでrelationはさらに絞り込まれていく。
>```rb
>    end
>```
>各単語に対するループ処理が終了する。
>```rb
>    relation
>```
>最終的に絞り込まれた記事のクエリオブジェクトをメソッドの戻り値として返している。
>```rb
>  end
>```
>searchメソッドの定義が終わっている。
>```rb
>  private
>```
>以下のメソッドはこのクラスの外部からは呼び出せないプライベートメソッドであることを示している。
>```rb
>  def title_words
>```
>title_wordsというプライベートメソッドを定義している。これはタイトルを単語に分割するためのメソッドだ。
>```rb
>    title.present? ? title.split(nil) : []
>```
>タイトル(title)が存在する場合はそのタイトルを空白文字で分割して単語の配列にし、存在しない場合は空の配列を返している。
>```rb
> end
>```
>title_wordsメソッドの定義が終わっている。
>```rb
>end
>```
>SearchArticlesFormクラスの定義が終わっている。
>このクラスは、指定されたカテゴリーとタイトルの単語を含む記事を検索するために使われるんだ。

ちなみに`distinct`メソッドはレコードの重複を除くというもの。なぜこの場合に必要なのかは今のところわからず。  
あと`by_category`とか`title_contain`は何者？と思ってたけどscopeだということが判明。たしかにメソッド以外にそういう可能性もあったな。覚えておこう。

大まかな実装方針としては
- `attribute`を追加
- scopeを追加
- 絞り込みロジックを`search`アクションに追加
- ビューにフォームを追加

って感じかな。
まず`attribute`の追加から着手するか。

必要な`attribute`は
- author_id(integer)
- tag_id(integer)
- body(string)

かな…？記事内容がちょっと自信ないというかまだよくわかってない。あくまで文章ブロックのみ対象でいいのか？  
一旦そこは保留にして追加する。

OK。次にscopeの追加。

OK。次は絞り込みロジックの追加。既存のを参考にやってみよう。

よし。ここまではOK。次にフォームの追加。

セレクトボックスの作り方。[参考記事](https://310nae.com/rails-selectbox/)
```erb
<%= f.select( プロパティ名, 選択肢, {オプション}, {HTMLオプション} ) %>
```
プロパティ名は送信する際のパラメータ名。通常はカラム（属性）名にすることが多い。なおHTMLオプションを使う場合は、無印オプションを省略できない。かならず空の大かっこを入れること。

`index.rb`見てて思ったんだけど、`=>`って何？どういう書き方？Slimの記法調べても出てこないんだけど…。ロボらんてくんに訊いてみるか。

ロボらんてくんにもしらんて言われた…。正確には「タイプミスじゃないかな」だけど。いいや一旦ほっとこう。

`pluck`について調べてたら`distinct`が必要な理由がわかった。これは`distinct`を呼び出した時点で重複を取り除くんじゃなくて、発行されるSQL文が`SELECT DISTINCT ...`になるっていう意味なんだたぶん。だから`モデル.distinct`としておいて、その後にどんなクエリが来てもレコードが重複しないようにしてるんだ。それこそ`pluck`は返り値が配列になるからメソッドチェーンの最後に持ってこなきゃいけないし。なるほどなあ。

よし、著者とタグのセレクトボックスはできた。次は記事内容のフォームだな。作るだけ作って、それから”記事内容”が実際には何を指すのか確かめよう。
今日はここまで。

# 2023.11.25
続きをやる。今日は著者での検索機能完成を目標にしたので、予定を変更して、先に著者検索だけでブラウザテストしてみる。

あれ、できない。昨日やったことだけでもうほぼ完成なんじゃと思ってたけどやっぱり違ったか…。最初からあるカテゴリーとタイトル検索はどうなってるんだろう？

こっちは普通にできる…。ええ〜なんで？

ストロングパラメータの設定を修正してなかった。直したらできた！とりあえず今日の目標は達成だ。  
あとついでに公開日の表示に余計なものが入ってるのに気づいたのでこれを消す。

う〜ん思ったより時間かかりそうなのでやっぱり後回しにする。

タグの検索機能行こう。タグは複数設定OKなところが他と違うからそこを考慮しないと。昨日書いた絞り込みロジックを修正する必要があるかも。

…の前に、このフォームの仕組みをざっくりと把握しておこう。

### 検索フォーム周りのざっくりとした仕組み
- `SearchArticlesForm`クラス
  - 疑似モデルクラス。これにより検索条件を1つのモデルインスタンス（のようなもの）として扱える
  - `search`メソッド：`SearchArticlesForm`クラスのインスタンスメソッド。`SearchArticlesForm`インスタンスを検索条件として、実際にデータの絞り込みを行う
- 検索フォーム
  - `admin/articles/index.html.slim`内にある`@search_articles_form`と紐づいた検索フォーム
  - 送信先は`admin_articles_path`（つまり`Admin::Articles#index`）
  - データベースの書き換えはしない（パラメータ飛ばすだけ）ので、**HTTPメソッドはGET**
- `Admin::Articles`コントローラ
  ```rb
    def index
      authorize(Article)

      @search_articles_form = SearchArticlesForm.new(search_params)
      # 検索フォームから送られてきたパラメータを元にSAFインスタンスを生成しインスタンス変数に代入

      @articles = @search_articles_form.search.order(id: :desc).page(params[:page]).per(25)
      # SAFインスタンスを基にデータの絞り込みを行い、並べ替えとページネーションの設定をし、その結果をインスタンス変数に代入
    end
  ```

よし、だいたい把握できた！  
改めてタグ検索の実装に取り掛かろう。

TagとArticleは多対多の関係なんだよな。これをうまくscopeに落とし込む方法を考えないと。  
アソシエーション使った書き方ってこの場合使えるのかな。使えるならそれが一番簡単そうだけど。  
いやだめか。単体のレコードに対してじゃないと使えないな多分。`where`とか`join`使って書くしか無いか。

ん〜〜、やりたいこととしては「idが`tag_id`であるタグが付いているArticleをすべて取得」なんだよな。`Tags.find(tag_id).articles`って感じ。ただあくまでレシーバーはArticlesにしたいんだよなあ。

とりあえず書いたので試してみる。

`TypeError:no implicit conversion of Symbol into String`がでた。シンボルじゃなくて文字列で書かないといけない部分があったらしい。  
あ、じゃなくてたぶん`joins`が`join`になってるせいかも。直してみる。

今度は`ActiveRecord::StatementInvalid at /admin/articles
Mysql2::Error: Unknown column 'articles.tag_id' in 'where clause'`。

解決＆実装成功！`where`をシンボル使って書く場合は、あくまで大元の（この場合`Articles`の）カラムしか条件に使えないんだ。結合した`article_tags`のほうのカラムを条件にしたい場合はプレースホルダー使って文字列でSQL書くしかないらしい（`article_tags.tag_id`みたいに）。

よーしこれで著者とタグはOK。残るは記事内容か。これが具体的に何を示してるのかまず確かめなきゃ。  
コンソール使って直接`body`になにか入れてみるか。

実験の結果、どうやら文章ブロックの内容のことらしい。article_blockは未だにどういう仕組かよくわかってないんだよなあ…。まずそこを解き明かすところからか〜。頑張る。

その前に、ずっと気になってたuuidについて調べた。Universally Unique IDentifier の略だそうだ。
通常のidだと単純すぎて色々推測できてしまうことがあるので、それを防ぐために規則性のないランダムなidを別に割り振り、それをパラメータ等に使っているということらしい。
[参考リンク](https://zenn.dev/yusuke_docha/articles/1b162804f7ea12)

話を戻してブロックの仕組みを調べる。  
とりあえず`ArticleBlock`クラスのコードを見た。`blockable`っていうのは`Sentence`、`Medium`、`Embed`の総称っぽいな。ようするに個々のブロックのこと。  
で、ここを勘違いしてたけど`ArticleBlock`は中間テーブルだ。`Article`と個々のブロックを繋いでる。  
ただし個々のブロックは3種類あってそれぞれ別のモデルだから、`blockable`っていう名称（関連名）をつけることで扱いやすくしてる。  
`Article`モデルの関連付けで`source: :blockable, source_type: 'Sentence'`って書いてるけどそんなことできるのか。sourceは必ずしも実在のモデルである必要はないってこと？ちょっと調べてみよう。

どうやらポリモーフィック関連付けというやつが関連している？

ビンゴ。  
ポリモーフィック関連付けとはなにか、ざっくりいうと「
異なるモデルを一つのグループとして扱えるようにする機能」。今回でいうと、`Sentence`、`Medium`、`Embed`という3つのモデルを`blockable`というグループにまとめている。グループ化する際の名称はどうやら`〇〇able`にするのが通例っぽい。  
詳細は[公式ドキュメント](https://railsguides.jp/v7.1/association_basics.html#%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%83%83%E3%82%AF%E9%96%A2%E9%80%A3%E4%BB%98%E3%81%91)参照。あとでまとめよう。

さてと、じゃあまず`Sentence`タイプの`blockable`をもつ`Article`を取得する方法を考えるか。そこからさらに`Sentence`の`body`の内容で絞り込みをかける方法を考える。

書いてみたので試してみる。

できてなかった。検索フォーム追加するの忘れてた。
フォーム追加したんだけど、`=>`の`>`はスペース空けるのに使ってる？`=`だと見本通りにフィールドの横に空白ができないな〜と思って、試しに`=>`にしたら見本通りになった。う〜ん謎。

お、検索機能自体はできたっぽい。ということは要件はもう満たせたのか？テストダウンロードしてやってみるか。

お、ほぼいい感じ。ただやっぱり記事内容は`body`っていう名前にしてるっぽいな。こっちに統一しよう。あとプレースホルダー忘れてたからそれも追加。

プレースホルダーについて。フィールドはOKだけど、セレクトボックスは意外と面倒そうなので一旦パス。あとでもう一回確認する。

OK！機能自体は完成。ここで一旦コミットしとこう。

さて、じゃあセレクトボックスのプレースホルダーを設定するか。見本に合わせて、プレースホルダーも選択可能だけどその場合値が`nil`になる、っていう挙動にしよう。

OK！そうしたら後はリファクタリングかな。  
できるとしたら`SearchArticleForm`だな。`relation`が大量に並んでる部分。うまくまとめられるかなあ。

う〜ん思いつかない。ロボらんてくんに頼んでみよ。

Articleモデルに提議したscopeを踏まえると、基本OKだけど、ワード検索は`inject`メソッド使ってもう少しスッキリさせられるよ、とのこと。
`inject`については[Rubyリファレンスマニュアル](https://docs.ruby-lang.org/ja/latest/method/Enumerable/i/inject.html)参照。こんな便利なメソッドあったんか…。

一応書けた。今日はここまで。明日はリファクタリングしたところが本当にこれでいいか再度確認して、それからRSpecの作成に入る。
